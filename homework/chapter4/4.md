 

 

 

**算法设计与分析第四章作业** 

| **姓名**  |                                                              | **班级** |      | **学号** |      |
| --------- | ------------------------------------------------------------ | -------- | ---- | -------- | ---- |
| **第1题** |                                                              |          |      |          |      |
| **第2题** |                                                              |          |      |          |      |
| **第3题** |                                                              |          |      |          |      |
| **第4题** |                                                              |          |      |          |      |
| **第5题** |                                                              |          |      |          |      |
| **第6题** |                                                              |          |      |          |      |
| **总分**  |                                                              |          |      |          |      |
| **备注**  | 作业提交截止时间：2020-10-28日24:00，超过提交截至时间的作业视为无效。确因网络等特殊原因无法及时提交作业的学生，应至少提前1小时与助教（何姗，QQ:1509394774）联系沟通。作业提交邮箱：[**hitsz_algo_2021@163.com**。](mailto:hitcsalgo2020@163.com。作业的首页要注明：学生姓名，班级，学号)。作业文件名命名方式： 第x章-x班-姓名-学号（例， 第1章-1班-张三-2018054000.doc）； 邮件主题为：第x章作业, x班，姓名，学号（例， 第1章作业，1班，张三，2018054000）。缺少这些信息的作业将被酌情扣分。 |          |      |          |      |

​      

 

 

 

 

 

 

1. （30分）在一条直线上有$n$堆石子，每堆有一定的数量，每次可以将两堆相邻的石子合并，合并后放在两堆的中间位置，合并的费用为两堆石子的总数。求把所有石子合并成一堆的最小花费(定义$dp[i][j]$为第$i$堆石子到第$j$堆合并的最小花费)。

   1. 写出该问题的递推方程。（10分）

      第$i$号到第$j$号的花费$ = dp[i][j] = \min(\{\text{第}i\text{号到第}k号的花费+\text{第}k+1\text{号到第}j\text{号}的花费+\text{第}i\text{到第}j\text{号的总重量},|i\le k<j\})$。

      $\therefore dp[i][j]=\min(dp[i][k]+dp[k+1][j]+s[j]-s[i-1]),i\le k<j, s[] 为石子数量的前缀和$。

   2. 有$5$堆石子$(n=5)$，每堆石子大小分别为$<1,3,5,2,4>$,求出把所有石子合并成一堆的最小花费(要求写出运算矩阵)。（10分）

      由递推方程计算得运算矩阵$dp[][]为$：

      ```
        0,   4,  13,  22,  34,
        0,   0,   8,  17,  28,
        0,   0,   0,   7,  17,
        0,   0,   0,   0,   6,
        0,   0,   0,   0,   0,
      ```

      由$dp[][]$定义知，$dp[1][n]=dp[1][5]=34$即为所求。

   3. 写出该问题的伪代码。（10分）
      $$
      \begin{align*}
      & MERGE\_STONES(n,w[1\dots n]) \\
      & \text{// n 为石子总数，w[1...n]为石子数量} \\
      & s[0] \leftarrow 0 \\
      & \textbf{for} \ i=1 \ \textbf{to} \ n \\
      & \quad s[i] \leftarrow s[i-1] + w[i] \\
      & \textbf{for} \ len=2 \ \textbf{to} \ n \\
      & \quad \textbf{for} \ i=1 \ \textbf{to} \ n+q-len \\
      & \qquad j \leftarrow i +len - 1 \\
      & \qquad dp[i][j] \leftarrow \infty \\
      & \qquad \textbf{for} \ k=i \ \textbf{to} \ j-1 \\
      & \qquad \quad dp[i][j] = \min(dp[i][j],dp[i][k]+dp[k+1][j]+s[j]-s[i-1]) \\
      & \textbf{return} \ dp[1][n] \\
      \end{align*}
      $$
      

2. 若7个关键字的概率如下所示，求其最优二叉搜索树的结构和代价，要求必须写出递推方程。（30分）

| $i$   | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| $p_i$ |      | 0.04 | 0.06 | 0.08 | 0.02 | 0.10 | 0.12 | 0.14 |
| $q_i$ | 0.06 | 0.06 | 0.06 | 0.06 | 0.05 | 0.05 | 0.05 | 0.05 |

 

3. 编程题：兑换零钱问题（40分）

   题目描述：

   给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回-1。（提示：你可以认为每种硬币的数量是无限的）。

   示例 1:

   输入: coins = [1, 2, 5], amount = 11

   输出: 3 

   解释: 11 = 5 + 5 + 1

    

   示例 2:

   输入: coins = [2], amount = 3

   输出: -1

   要求：运用动态规划的思想作答，请写出分析过程和状态转移方程，并用一种语言（最好是C++或JAVA）实现你的思路（粘贴在交作业的那个word里），并保证代码能正确运行，复杂度尽可能低。

 

 

 

 